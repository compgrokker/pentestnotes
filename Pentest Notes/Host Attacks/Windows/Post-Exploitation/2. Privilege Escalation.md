
## The cheater eJPT  way
get PrivescCheck from github
https://github.com/itm4n/PrivescCheck

run script 
`powershell -ep bypass -c ". .\PrivescCheck.ps1; Invoke-PrivescCheck`

use creds it finds
`runas.exe /user:<user> cmd`

## The OSCP way

four different concepts and mechanisms: _Security Identifier_ (SID),[1](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-1) _access token_,[2](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-2) _Mandatory Integrity Control_,[3](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-3) and _User Account Control_.[4](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-4)

Windows uses a SID to identify entities. A SID is a unique value assigned to each entity, or _principal_, that can be authenticated by Windows, such as users and groups. The SID for local accounts and groups is generated by the _Local Security Authority_ (LSA),[5](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-5) and for domain users and domain groups, it's generated on a _Domain Controller_ (DC). The SID cannot be changed and is generated when the user or group is created.

The SID string consists of different parts, delimited by "-", and represented by the placeholders "S", "R", "X", and "Y" in the following listing. This representation is the fundamental structure of a SID.

```
S-R-X-Y
```

> Listing 1 - SID representation

The first part is a literal "S", which indicates that the string is a SID.

"R" stands for _revision_ and is always set to "1", since the overall SID structure continues to be on its initial version.

"X" determines the identifier authority. This is the authority that issues the SID. For example, "5" is the most common value for the identifier authority. It specifies _NT Authority_ and is used for local or domain users and groups.

"Y" represents the sub authorities of the identifier authority. Every SID consists of one or more sub authorities. This part consists of the domain identifier and _relative identifier_ (RID). The domain identifier is the SID of the domain for domain users, the SID of the local machine for local users, and "32" for built-in principals. The RID determines principals such as users or groups.

The following listing shows an example SID of a local user on a Windows system:

```
S-1-5-21-1336799502-1441772794-948155058-1001
```

> Listing 2 - SID representation

 the RID is 1001. Because the RID starts at 1000 for nearly all principals, this implies that this is the second local user created on the system.

There are SIDs that have a RID under 1000, which are called _well-known SIDs_.[6](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-6) These SIDs identify generic and built-in groups and users instead of specific groups and users. The following listing contains some useful well-known SIDs in the context of privilege escalation.

```
S-1-0-0                       Nobody        
S-1-1-0	                      Everybody
S-1-5-11                      Authenticated Users
S-1-5-18                      Local System
S-1-5-domainidentifier-500    Administrator
```

> Listing 3 - List of Well known SIDs on local machines

how Windows determines whether to grant or deny operations. Once a user is authenticated, Windows generates an access token that is assigned to that user. The token itself contains various pieces of information that effectively describe the _security context_ of a given user. The security context is a set of rules or attributes that are currently in effect.

The security context of a token consists of the SID of the user, SIDs of the groups the user is a member of, the user and group privileges, and further information describing the scope of the token.

token is assigned to threads started by user. "primary token" specifies permissions for interactions with other objects.

"impersonation token" used to provide different security contexts. (think sudo)

5 integrity levels
```
- System: SYSTEM (kernel, ...)
- High: Elevated users
- Medium: Standard users
- Low: Very restricted rights often used in sandboxed[^privesc_win_sandbox] processes or for directories storing temporary data
- Untrusted: Lowest integrity level with extremely limited access rights for processes or objects that pose the most potential risk
```

another Windows security technology we need to consider is _User Account Control_ (UAC). UAC is a Windows security feature that protects the operating system by running most applications and tasks with standard user privileges, even if the user launching them is an Administrator. For this, an administrative user obtains two access tokens after a successful logon. The first token is a standard user token (or _filtered admin token_), which is used to perform all non-privileged operations. The second token is a regular administrator token. It will be used when the user wants to perform a privileged operation. To leverage the administrator token, a UAC consent prompt[10](https://portal.offsec.com/courses/pen-200-44065/learning/windows-privilege-escalation-45276/enumerating-windows-47207/understanding-windows-privileges-and-access-control-mechanisms-45278#fn-local_id_48-10) needs to be confirmed.


## Leveraging Windows Services

Services are Windows equivalent of linux/unix daemons.  Managed with services snap-in, powershell, or sc.exe.  Uses LocalSystem (includes SIDs of _NT AUTHORITY\SYSTEM_ and _BUILTIN\Administrators_ in its token), Network Service, and Local Service accounts.
### Service Binary Hijacking
Given improperly secured program with full Read/Write permissions for all members of Users group, an unprivileged user could replaces the program with a malicious one then trigger the binary to to run, gaining permissions of the service (ie, LocalSystem).

To get a list of all installed Windows services, use either the GUI snap-in _services.msc_, the _Get-Service_ Cmdlet, or the _Get-CimInstance_ Cmdlet (superseding _Get-WmiObject_).

`Get-CimInstance -ClassName win32_service | Select Name,State,PathName | Where-Object {$_.State -like 'Running'}`
When using a network logon such as WinRM or a bind shell, Get-CimInstance and Get-Service will result in a "permission denied" error when querying for services with a non-administrative user. Using an interactive logon such as RDP solves this problem.
look  for services started outside `C:\Windows\System32` as prime candidates for hijacking.
### Service DLL Hijacking


### Unquoted Service Paths

